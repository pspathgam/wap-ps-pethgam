<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Winter Assignment Portal Zone Wagoora (v9 - Approval & Trophies)</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Load Firebase SDKs -->
    <script type="module">
        // Import necessary Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, collection, query, onSnapshot, 
            addDoc, serverTimestamp, getDocs, where, orderBy, deleteDoc, updateDoc,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getDatabase, ref as dbRef, update as dbUpdate, onValue as dbOnValue, set as dbSet } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        // Set log level to debug for thorough debugging
        setLogLevel('debug');

        // Global Firebase variables provided by the environment
        const firebaseConfig = {
            apiKey: "AIzaSyCBLLmzxVYuivT15HBPPSxMoS2OzojRgJM",
            authDomain: "wap-ps-pethgam.firebaseapp.com",
            databaseURL: "https://wap-ps-pethgam-default-rtdb.firebaseio.com",
            projectId: "wap-ps-pethgam",
            storageBucket: "wap-ps-pethgam.firebasestorage.app",
            messagingSenderId: "430925411362",
            appId: "1:430925411362:web:22857dee585d02fc54467b"
        };

        // Initialize Firebase services
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const rtdb = getDatabase(app);

        // --- GLOBAL STATE & FIREBASE PATHS ---
        let userId = null;
        let username = null;
        let role = null;
        let isAuthReady = false;
        let rtdbWatchId = null;
        let allUsers = {}; // Cache for all users loaded from Firestore for login validation

        // Retrieve app ID and define collection paths based on environment rules
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // MANDATORY PUBLIC PATH STRUCTURE: /artifacts/{appId}/public/data/{collectionName}
        const USER_COLLECTION_PATH = `artifacts/${appId}/public/data/users`;
        const ASSIGNMENTS_COLLECTION_PATH = `artifacts/${appId}/public/data/assignments`;
        const LEADERBOARD_COLLECTION_PATH = `artifacts/${appId}/public/data/leaderboard`;

        const USER_COLLECTION = collection(db, USER_COLLECTION_PATH);

        // --- CONSTANTS ---
        const AVAILABLE_CLASSES = ["1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th"];
        const AVAILABLE_SUBJECTS = ["Math", "English", "EVS", "Urdu", "Kashmiri", "SST"];
        const AVAILABLE_SCHOOLS = ["PS Pethgam Wagoora", "MS Wagoora", "HS Wagoora", "Other School"];
        const TROPHY_THRESHOLDS = {
            GOLD: 6000,
            SILVER: 4000,
            BRONZE: 2000
        };
        
        // Initial Admin is hardcoded for first login. Status is implicitly 'Approved'
        const INITIAL_ADMIN = { 
            "Admin_Pethgam": { role: "Admin", pin: "0000", school: "PS Pethgam Wagoora", status: "Approved" } 
        };

        // --- UI ELEMENTS ---
        const errorEl = document.getElementById('error-message');
        const loginFormEl = document.getElementById('login-form');
        const loginContainerEl = document.getElementById('login-container');
        const userSignupFormEl = document.getElementById('user-signup-form');
        const userSignupContainerEl = document.getElementById('user-signup-container');
        const assignmentContainerEl = document.getElementById('assignment-portal-container');
        const welcomeMessageEl = document.getElementById('welcome-message');
        const teacherViewEl = document.getElementById('teacher-view'); 
        const studentViewEl = document.getElementById('student-view');
        const adminViewEl = document.getElementById('admin-view');
        const userListTableBodyEl = document.getElementById('user-list-table-body');
        const assignmentFormEl = document.getElementById('assignment-form');
        const assignmentListEl = document.getElementById('assignment-list');
        const leaderboardTableBodyEl = document.getElementById('leaderboard-table-body');
        const notificationMarqueeEl = document.getElementById('notification-marquee');
        
        // Geolocation elements
        const locationControlsEl = document.getElementById('location-controls');
        const signupClassFieldEl = document.getElementById('signup-class-field');


        // --- FIREBASE AUTHENTICATION & INITIALIZATION ---

        async function initAuth() {
            onAuthStateChanged(auth, (user) => {
                if (user) userId = user.uid;
                else userId = null;
                isAuthReady = true;
                checkSession();
            });
            await signInAnonymously(auth);
        }

        // --- USER LOADING (For Login Validation & Admin Management) ---

        async function loadAllUsers() {
            const snapshot = await getDocs(USER_COLLECTION);
            allUsers = {};
            snapshot.forEach(doc => {
                const data = doc.data();
                allUsers[data.username] = { ...data, id: doc.id };
            });
            console.log("User cache loaded/refreshed:", Object.keys(allUsers).length, "users.");
            return allUsers;
        }

        // --- USER SIGNUP (Unified for Teacher/Student) ---

        function showSignup() {
            loginContainerEl.classList.add('hidden');
            userSignupContainerEl.classList.remove('hidden');
            
            // Populate Class/School dropdowns
            document.getElementById('user-signup-role').value = ''; // Reset role
            document.getElementById('user-signup-class').innerHTML = AVAILABLE_CLASSES.map(c => `<option value="${c}">${c}</option>`).join('');
            document.getElementById('user-signup-school').innerHTML = AVAILABLE_SCHOOLS.map(s => `<option value="${s}">${s}</option>`).join('');
            document.getElementById('signup-error-message').textContent = '';
            signupClassFieldEl.classList.add('hidden'); // Hide class initially
        }

        function showLogin() {
            loginContainerEl.classList.remove('hidden');
            userSignupContainerEl.classList.add('hidden');
            document.getElementById('signup-error-message').textContent = '';
        }

        async function handleUserSignup(event) {
            event.preventDefault();
            
            const signupRole = document.getElementById('user-signup-role').value;
            // Trim whitespace from user inputs (CRITICAL: prevents silent data mismatch)
            const signupUsername = document.getElementById('user-signup-username').value.trim();
            const signupPin = document.getElementById('user-signup-pin').value.trim();
            const signupClass = document.getElementById('user-signup-class').value;
            const signupSchool = document.getElementById('user-signup-school').value;
            const signupErrorEl = document.getElementById('signup-error-message');

            if (!signupRole || !signupUsername || !signupPin || !signupSchool || (signupRole === 'Student' && !signupClass)) {
                signupErrorEl.textContent = 'Please fill all required fields.';
                return;
            }
            if (signupRole === 'Student' && !AVAILABLE_CLASSES.includes(signupClass)) {
                signupErrorEl.textContent = 'Invalid class selection for Student role.';
                return;
            }
            // Check if username already exists in the latest cache
            if (allUsers[signupUsername] || INITIAL_ADMIN[signupUsername]) {
                signupErrorEl.textContent = 'Error: Username already exists!';
                return;
            }
            
            try {
                // All new signups are set to 'Pending'
                await addDoc(USER_COLLECTION, {
                    username: signupUsername,
                    role: signupRole,
                    pin: signupPin,
                    class: (signupRole === 'Student') ? signupClass : null,
                    school: signupSchool,
                    status: 'Pending', // NEW: Requires Admin Approval
                    createdAt: serverTimestamp()
                });
                
                signupErrorEl.textContent = `Signup successful! Your account is pending Admin approval. You may now attempt to log in.`;
                userSignupFormEl.reset();
                // Ensure cache is updated immediately after successful creation
                await loadAllUsers(); 
                // Don't auto-redirect, let them try login and see the pending message
                // setTimeout(showLogin, 3000);

            } catch (e) {
                console.error("Signup error:", e);
                signupErrorEl.textContent = `Signup error: ${e.message}`;
            }
        }
        
        // --- LOGIN/SESSION LOGIC (IMPROVED PIN/STATUS HANDLING) ---
        
        function handleLogout(suppressMessage = false) {
            stopSharing();
            sessionStorage.clear();
            
            loginContainerEl.classList.remove('hidden');
            assignmentContainerEl.classList.add('hidden');
            userSignupContainerEl.classList.add('hidden'); 
            
            // Clear role-specific views
            teacherViewEl.classList.add('hidden');
            studentViewEl.classList.add('hidden');
            adminViewEl.classList.add('hidden');

            if (!suppressMessage) {
                 errorEl.textContent = 'Logged out successfully.';
            } else {
                 errorEl.textContent = '';
            }
            
            signOut(auth).catch(err => console.error("Firebase logout error:", err));
        }


        async function handleLogin(event) {
            event.preventDefault();
            
            // 1. Get Inputs and TRIM whitespace (CRITICAL)
            const selectedRole = document.getElementById('role-select').value;
            const inputUsername = document.getElementById('username-input').value.trim();
            const inputPin = document.getElementById('pin-input').value.trim(); // Trimmed input pin
            
            errorEl.textContent = '';
            
            if (!inputUsername || !inputPin || !selectedRole) {
                errorEl.textContent = 'Please fill in all login fields.';
                return;
            }

            // 2. Refresh User Cache (CRITICAL)
            await loadAllUsers(); 
            
            let userData = null;
            let school = null;
            let userClass = null;
            
            // 3. Check hardcoded Admin first
            const initialUser = INITIAL_ADMIN[inputUsername];
            if (initialUser) {
                 userData = initialUser;
            } else {
                 // 4. Check users loaded from Firestore cache
                 userData = allUsers[inputUsername];
            }

            console.log("--- Attempting Login ---");
            console.log("Input: Username:", inputUsername, "Role:", selectedRole, "PIN:", inputPin);

            if (userData) {
                console.log("Stored Data:", userData);

                // A. Validate PIN
                if (userData.pin === inputPin) {
                    
                    // B. Validate ROLE
                    if (userData.role === selectedRole) {
                        
                        // C. Validate STATUS (NEW: Admin Approval Check)
                        if (userData.status === 'Approved') {
                             school = userData.school;
                             userClass = userData.class;
                        
                             // Set global state and session storage
                             username = inputUsername;
                             role = selectedRole; 
                        
                             await finalizeLogin(username, role, userClass, school);
                             return;
                        } else {
                             // Status is not Approved (must be 'Pending')
                             errorEl.textContent = 'Login Failed: Your account is awaiting Admin approval.';
                             console.error("Login Failed: Account status is", userData.status);
                             return;
                        }
                    } else {
                        // Role mismatch error
                        errorEl.textContent = `Login Failed: Invalid Role. Please ensure you selected the correct role for this username.`;
                        console.error("Login Failed: Role mismatch. Stored:", userData.role, "Selected:", selectedRole);
                    }
                } else {
                    // PIN mismatch error
                    errorEl.textContent = 'Login Failed: Invalid PIN.';
                    console.error("Login Failed: PIN mismatch. Stored PIN:", userData.pin, "Input PIN:", inputPin);
                }
            } else {
                // User not found error
                errorEl.textContent = 'Login Failed: Invalid Username or Role combination.';
                console.error("Login Failed: Username not found in cache or admin list.");
            }
        }
        
        async function finalizeLogin(user, userRole, userClass, userSchool) {
            sessionStorage.setItem('portal_logged_in', 'true');
            sessionStorage.setItem('portal_username', user);
            sessionStorage.setItem('portal_role', userRole);
            sessionStorage.setItem('portal_class', userClass || '');
            sessionStorage.setItem('portal_school', userSchool || '');
            
            username = user;
            role = userRole;
            
            transitionToAssignmentPortal(user, userRole);
        }

        async function checkSession() {
            if (isAuthReady) {
                await loadAllUsers(); 

                const loggedIn = sessionStorage.getItem('portal_logged_in') === 'true';
                if (loggedIn) {
                    username = sessionStorage.getItem('portal_username');
                    role = sessionStorage.getItem('portal_role');
                    transitionToAssignmentPortal(username, role);
                } else {
                    loginContainerEl.classList.remove('hidden');
                    assignmentContainerEl.classList.add('hidden');
                    userSignupContainerEl.classList.add('hidden');
                }
            }
        }

        function transitionToAssignmentPortal(user, userRole) {
            loginContainerEl.classList.add('hidden');
            userSignupContainerEl.classList.add('hidden');
            assignmentContainerEl.classList.remove('hidden');
            welcomeMessageEl.textContent = `Welcome, ${user} (${userRole} from ${sessionStorage.getItem('portal_school')})!`;
            
            // Role-Based View Switching
            const isAdmin = userRole === 'Admin';
            const isTeacher = userRole === 'Teacher';
            const isStudent = userRole === 'Student';
            
            // Teacher/Admin can see assignment form
            teacherViewEl.classList.toggle('hidden', !(isTeacher || isAdmin)); 
            // Student sees assignment list
            studentViewEl.classList.toggle('hidden', !isStudent);
            // Admin only views
            adminViewEl.classList.toggle('hidden', !isAdmin);
            document.getElementById('nav-user-management').classList.toggle('hidden', !isAdmin);
            document.getElementById('nav-location').classList.toggle('hidden', !isAdmin);
            
            locationControlsEl.classList.toggle('hidden', !isAdmin); 
            
            // Populate Class/Subject/School dropdowns
            if(isTeacher || isAdmin) {
                 const classSelect = document.getElementById('assignment-class-select');
                 const subjectSelect = document.getElementById('assignment-subject-select');
                 classSelect.innerHTML = AVAILABLE_CLASSES.map(c => `<option value="${c}">${c}</option>`).join('');
                 subjectSelect.innerHTML = AVAILABLE_SUBJECTS.map(s => `<option value="${s}">${s}</option>`).join('');
                 
                 // Admin User Management Fields
                 if (isAdmin) {
                     document.getElementById('new-user-class').innerHTML = AVAILABLE_CLASSES.map(c => `<option value="${c}">${c}</option>`).join('');
                     document.getElementById('new-user-school').innerHTML = AVAILABLE_SCHOOLS.map(s => `<option value="${s}">${s}</option>`).join('');
                 }
            }
            
            // Set default view based on role
            if (isAdmin) {
                showView('user-management'); // Admin lands on User Management
                setupUserListListener(); 
            } else {
                showView('assignments'); // Student/Teacher lands on Assignments
            }
            
            setupAssignmentListeners();
            setupDataListener(); // Start listening for live location
            setupNotificationListener(); // Start listening for live notifications
        }
        
        // --- NOTIFICATION MANAGEMENT (RTDB) ---
        
        const NOTIFICATION_PATH = 'notifications/main_message';

        function setupNotificationListener() {
            const notificationRef = dbRef(rtdb, NOTIFICATION_PATH);

            dbOnValue(notificationRef, (snapshot) => {
                const message = snapshot.val() || 'Welcome to the Winter Assignment Portal Zone Wagoora. Stay tuned for important updates!';
                notificationMarqueeEl.textContent = message;
            }, (error) => {
                console.error("Error listening to notification:", error);
                notificationMarqueeEl.textContent = 'Error loading updates.';
            });
        }

        async function handleNotificationUpdate(event) {
            event.preventDefault();
            
            const newMessage = document.getElementById('notification-input').value.trim();
            const notificationErrorEl = document.getElementById('notification-error-message');

            if (!newMessage) {
                 notificationErrorEl.textContent = 'Notification message cannot be empty.';
                 return;
            }
            
            try {
                await dbSet(dbRef(rtdb, NOTIFICATION_PATH), newMessage);
                notificationErrorEl.textContent = 'Notification updated successfully!';
                setTimeout(() => notificationErrorEl.textContent = '', 3000);
            } catch (e) {
                 console.error("Error updating notification:", e);
                 notificationErrorEl.textContent = `Error: ${e.message}`;
            }
        }

        // --- USER MANAGEMENT (ADMIN ONLY - FIRESTORE) ---

        function setupUserListListener() {
            if (!isAuthReady) return;

            const usersQuery = query(USER_COLLECTION, orderBy('status'), orderBy('role'), orderBy('username'));
            
            onSnapshot(usersQuery, (snapshot) => {
                const users = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderUserList(users);
            }, (error) => {
                console.error("Error listening to users:", error);
            });
        }
        
        function renderUserList(users) {
             if (role !== 'Admin') return;
             
             userListTableBodyEl.innerHTML = users.map(user => {
                 const isPending = user.status === 'Pending';
                 const statusClass = isPending ? 'text-red-400 font-bold' : 'text-green-400';
                 
                 return `
                 <tr class="text-sm border-t border-gray-600">
                     <td class="p-3 font-semibold text-yellow-400">${user.username}</td>
                     <td class="p-3">${user.role}</td>
                     <td class="p-3 font-mono text-xs">${user.pin}</td> 
                     <td class="p-3">${user.class || '-'}</td>
                     <td class="p-3 ${statusClass}">${user.status || 'N/A'}</td>
                     <td class="p-3 text-right space-x-2">
                         ${isPending ? `
                             <button data-id="${user.id}" data-action="approve"
                                     onclick="handleUserAction(event)"
                                     class="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700 transition">
                                 Approve
                             </button>
                         ` : ''}
                         <button data-id="${user.id}" data-action="delete"
                                 data-username="${user.username}" 
                                 onclick="handleUserAction(event)"
                                 class="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition">
                             Delete
                         </button>
                     </td>
                 </tr>
             `}).join('');
        }

        window.handleUserAction = async function(event) {
             const userIdToUpdate = event.target.getAttribute('data-id');
             const action = event.target.getAttribute('data-action');
             const userName = event.target.getAttribute('data-username');
             const adminErrorEl = document.getElementById('admin-error-message');
             
             const userDocRef = doc(db, USER_COLLECTION_PATH, userIdToUpdate);

             try {
                 if (action === 'delete') {
                     // Using console error instead of confirm/alert to adhere to rules
                     console.error(`Deletion of user ${userName} requested.`);
                     await deleteDoc(userDocRef);
                     adminErrorEl.textContent = `User ${userName || 'User'} deleted successfully.`;
                 } else if (action === 'approve') {
                     await updateDoc(userDocRef, {
                         status: 'Approved'
                     });
                     adminErrorEl.textContent = `User approved successfully! They can now log in.`;
                 }
                 
                 // Refresh cache after modification
                 await loadAllUsers(); 
                 setTimeout(() => adminErrorEl.textContent = '', 3000);

             } catch (e) {
                 console.error(`Error performing action ${action} on user:`, e);
                 adminErrorEl.textContent = `Error during user action: ${e.message}`;
             }
        }
        
        async function handleUserAdd(event) {
            event.preventDefault();
            
            const newUserRole = document.getElementById('new-user-role').value;
            const newUsername = document.getElementById('new-user-username').value.trim();
            const newPin = document.getElementById('new-user-pin').value.trim(); 
            const newSchool = document.getElementById('new-user-school').value;
            const newClass = document.getElementById('new-user-class').value;
            const adminErrorEl = document.getElementById('admin-error-message');

            if (!newUserRole || !newUsername || !newPin || !newSchool || (newUserRole === 'Student' && !newClass)) {
                adminErrorEl.textContent = 'Please fill all required fields.';
                return;
            }

            if (allUsers[newUsername] || INITIAL_ADMIN[newUsername]) {
                adminErrorEl.textContent = 'Error: Username already exists!';
                return;
            }
            
            try {
                const userData = {
                    username: newUsername,
                    role: newUserRole, 
                    pin: newPin, 
                    school: newSchool,
                    class: (newUserRole === 'Student') ? newClass : null, 
                    status: 'Approved', // Admin added users are automatically approved
                    createdBy: username,
                    createdAt: serverTimestamp()
                };
                
                await addDoc(USER_COLLECTION, userData);
                
                adminErrorEl.textContent = `${newUserRole} ${newUsername} added and approved successfully!`;
                document.getElementById('user-add-form').reset();
                await loadAllUsers(); 

            } catch (e) {
                console.error("Admin user add error:", e);
                adminErrorEl.textContent = `Error adding user: ${e.message}`;
            }
        }
        
        // --- ASSIGNMENT MANAGEMENT ---

        async function handleAssignmentSubmit(event) {
            event.preventDefault();
            
            const selectedClass = document.getElementById('assignment-class-select').value;
            const selectedSubject = document.getElementById('assignment-subject-select').value;
            const question = document.getElementById('assignment-question').value.trim();
            
            const optionA = document.getElementById('assignment-option-a').value.trim();
            const optionB = document.getElementById('assignment-option-b').value.trim();
            const optionC = document.getElementById('assignment-option-c').value.trim();
            const optionD = document.getElementById('assignment-option-d').value.trim();
            
            const correctKey = document.getElementById('assignment-correct-key').value; 
            
            if (!selectedClass || !selectedSubject || !question || !optionA || !optionB || !optionC || !optionD || !correctKey) {
                errorEl.textContent = 'Please fill all fields (Class, Subject, Question, and all 4 Options).';
                return;
            }

            try {
                const assignmentData = {
                    class: selectedClass,
                    subject: selectedSubject,
                    question: question,
                    options: {
                        A: optionA,
                        B: optionB,
                        C: optionC,
                        D: optionD
                    },
                    correctKey: correctKey, 
                    createdBy: username,
                    school: sessionStorage.getItem('portal_school'),
                    timestamp: serverTimestamp(),
                    status: 'Active'
                };
                
                const assignmentsCollectionRef = collection(db, ASSIGNMENTS_COLLECTION_PATH);
                await addDoc(assignmentsCollectionRef, assignmentData);
                
                errorEl.textContent = 'Assignment published successfully!';
                assignmentFormEl.reset();
            } catch (e) {
                console.error("Error adding document: ", e);
                errorEl.textContent = `Error adding assignment: ${e.message}`;
            }
        }

        function setupAssignmentListeners() {
            if (!isAuthReady) return;

            // 1. Listen for all assignments
            const assignmentsCollectionRef = collection(db, ASSIGNMENTS_COLLECTION_PATH);
            const assignmentsQuery = query(assignmentsCollectionRef, orderBy('timestamp', 'desc'));
            
            onSnapshot(assignmentsQuery, (snapshot) => {
                const assignments = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderAssignments(assignments);
            }, (error) => {
                console.error("Error listening to assignments:", error);
            });
            
            // 2. Listen for leaderboard data
            const leaderboardCollectionRef = collection(db, LEADERBOARD_COLLECTION_PATH);
            const leaderboardQuery = query(leaderboardCollectionRef); // No orderBy to allow sorting in memory
            
            onSnapshot(leaderboardQuery, (snapshot) => {
                const scores = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderLeaderboard(scores);
            }, (error) => {
                console.error("Error listening to leaderboard:", error);
            });
        }
        
        function renderAssignments(assignments) {
            if (role !== 'Student') return;

            const studentClass = sessionStorage.getItem('portal_class');
            
            const filteredAssignments = assignments.filter(a => a.class === studentClass);

            if (filteredAssignments.length === 0) {
                assignmentListEl.innerHTML = '<p class="text-center text-gray-400">No assignments available for your class.</p>';
                return;
            }

            assignmentListEl.innerHTML = filteredAssignments.map(a => {
                const submissionStatus = sessionStorage.getItem(`submitted_${a.id}`) || 'pending';
                const isDisabled = submissionStatus === 'submitted' ? 'disabled' : '';
                const options = a.options || {}; 

                return `
                    <div id="assignment-${a.id}" class="card p-4 mb-3 border-l-4 border-yellow-500">
                        <p class="font-bold text-lg text-yellow-400">${a.class} / ${a.subject} (${a.school})</p>
                        <p class="text-gray-300 mb-4 font-medium">${a.question}</p>
                        
                        <!-- Multiple Choice Options -->
                        <fieldset id="options-group-${a.id}" class="space-y-2 mb-4">
                            ${['A', 'B', 'C', 'D'].map(key => `
                                <div class="flex items-center option-item ${isDisabled ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-700/50 cursor-pointer'} p-2 rounded transition">
                                    <input type="radio" 
                                           id="option-${a.id}-${key}" 
                                           name="answer-${a.id}" 
                                           value="${key}" 
                                           class="form-radio h-5 w-5 text-teal-500 bg-gray-600 border-gray-500 focus:ring-teal-500" 
                                           ${isDisabled}>
                                    <label for="option-${a.id}-${key}" class="ml-3 text-gray-300 flex-1">
                                        <span class="font-bold mr-2 text-teal-300">${key}.</span> ${options[key] || 'No Option Provided'}
                                    </label>
                                </div>
                            `).join('')}
                        </fieldset>

                        <button data-id="${a.id}" data-correct="${a.correctKey}" 
                                class="submit-assignment-btn w-full bg-teal-500 text-white py-2 rounded hover:bg-teal-600 transition ${isDisabled ? 'bg-gray-500 hover:bg-gray-500 cursor-not-allowed' : ''}" 
                                ${isDisabled}>
                            Submit Answer
                        </button>
                        <p id="feedback-${a.id}" class="mt-2 text-sm font-semibold text-center"></p>
                    </div>
                `;
            }).join('');

            document.querySelectorAll('.submit-assignment-btn').forEach(button => {
                button.addEventListener('click', handleStudentSubmission);
            });
        }
        
        async function handleStudentSubmission(event) {
            const assignmentId = event.target.getAttribute('data-id');
            const correctKey = event.target.getAttribute('data-correct'); 
            
            const selectedOptionEl = document.querySelector(`input[name="answer-${assignmentId}"]:checked`);
            const feedbackEl = document.getElementById(`feedback-${assignmentId}`);
            const optionsGroupEl = document.getElementById(`options-group-${assignmentId}`);

            if (!selectedOptionEl) {
                feedbackEl.textContent = 'Please select an answer option.';
                feedbackEl.className = 'mt-2 text-sm font-semibold text-yellow-400';
                return;
            }

            const studentKey = selectedOptionEl.value;
            const isCorrect = studentKey === correctKey;
            const score = isCorrect ? 10 : 0;
            
            const feedback = isCorrect 
                ? 'Wow! You are doing Wonderful.' 
                : 'No problem, Try next time.';
            const feedbackClass = isCorrect ? 'text-green-500' : 'text-red-500';

            feedbackEl.textContent = feedback;
            feedbackEl.className = `mt-2 text-sm font-semibold ${feedbackClass}`;
            
            // Disable all controls
            document.querySelectorAll(`input[name="answer-${assignmentId}"]`).forEach(input => input.disabled = true);
            event.target.disabled = true;
            event.target.classList.replace('bg-teal-500', 'bg-gray-500');
            optionsGroupEl.classList.add('opacity-50');
            
            sessionStorage.setItem(`submitted_${assignmentId}`, 'submitted');

            try {
                const leaderboardCollectionRef = collection(db, LEADERBOARD_COLLECTION_PATH);
                const existingSubmissionsQuery = query(
                    leaderboardCollectionRef, 
                    where('assignmentId', '==', assignmentId), 
                    where('studentId', '==', userId)
                );
                const existingSnapshot = await getDocs(existingSubmissionsQuery);
                
                if (existingSnapshot.empty) {
                     await addDoc(leaderboardCollectionRef, {
                        assignmentId: assignmentId,
                        studentId: userId, // Use UID for unique tracking
                        username: username,
                        class: sessionStorage.getItem('portal_class'),
                        school: sessionStorage.getItem('portal_school'),
                        score: score,
                        isCorrect: isCorrect,
                        timestamp: serverTimestamp()
                    });
                }
            } catch (e) {
                console.error("Error saving leaderboard score: ", e);
            }
        }
        
        function getTrophy(score) {
            if (score >= TROPHY_THRESHOLDS.GOLD) return 'ðŸ¥‡ Gold';
            if (score >= TROPHY_THRESHOLDS.SILVER) return 'ðŸ¥ˆ Silver';
            if (score >= TROPHY_THRESHOLDS.BRONZE) return 'ðŸ¥‰ Bronze';
